/** \file
 *
 * \brief The main header for the Enhanced Enum library
 */

#include <array>
#include <optional>
#include <type_traits>

/** \brief The main namespace for the Enhanced Enum library
 */
namespace enhanced_enum {

/** \brief Base class for an enhanced enum type
 *
 * Each enhanced enum type supported by this library derives from this
 * class. The derived class only needs to provide the values for the
 * enumerators. The capabilities of the enum type are then implemented by the
 * base class. The intention is that the definition of the derived class is
 * autogenerated.
 *
 * There is one-to-one correspondence between the unique instances of an \c
 * EnhancedEnum, and the enumerators of the underlying \c LabelEnum. Thus
 * conceptually the instances of \c EnhancedEnum are its enumerators, and will
 * be called so in this class reference.
 *
 * An instance of \c EnhancedEnum only needs to store the value of the label
 * enumerator. Consequently, most of the traits of a C++ enum type are also
 * traits of the \c EnhancedEnum type: the type is trivial, layout compatible
 * with \c LabelEnum, and implements the same set of operators that work on the
 * built-in enums.
 *
 * \note It is assumed that the definition of the derived class is
 * compatible with the requirements imposed by the library. Most
 * notably the derived class must not have any non-static data members
 * or other non-empty base classes. The easiest way to ensure
 * compatibility is to autogenerate the definition.
 *
 * \tparam EnhancedEnum The derived enhanced enum type. The base class template
 * uses curiously recurring template pattern.
 * \tparam LabelEnum The underlying C++ enum (<tt>enum class</tt>)
 * \tparam ValueType The enumerator value type
 */
template<
    typename EnhancedEnum, typename LabelEnum, typename ValueType>
struct enum_base {
    static_assert( std::is_enum_v<LabelEnum> );

    using label_type = LabelEnum;   ///< \brief Alias for the label enum type
    using value_type = ValueType;   ///< \brief Alias for the value type

    /** \brief Get the number of enumerators
     *
     * \return The number of enumerators in this enum
     */
    static constexpr std::size_t size() noexcept
    {
        return EnhancedEnum::values.size();
    }

    /** \brief Get the number of enumerators as signed number
     *
     * \return The number of enumerators in this enum
     */
    static constexpr std::ptrdiff_t ssize() noexcept
    {
        return static_cast<std::ptrdiff_t>(size());
    }

    /** \brief Get range over all enumerators
     *
     * \return A random accessible range containing all enumerators in
     * the order they are declared
     */
    static constexpr auto all() noexcept
    {
        constexpr auto N = size();
        auto ret = std::array<EnhancedEnum, N> {};
        for (auto i = 0u; i < N; ++i) {
            ret[i] = static_cast<LabelEnum>(i);
        }
        return ret;
    }

    /** \brief Get the enumerator associated with \p value
     *
     * \note The number of comparisons is linear in the size of the
     * enumeration. The assumption is that the number of enumerators
     * is small and the values are localized in memory, making linear
     * algorithm efficient in practice.
     *
     * \param value The value to search
     *
     * \return The first enumerator whose value is \p value, or empty
     * if no such enumerator exists
     */
    static constexpr std::optional<EnhancedEnum> from(const value_type& value) noexcept
    {
        for (const auto e : all()) {
            if (e.value() == value) {
                return e;
            }
        }
        return std::nullopt;
    }

    /** \brief Default constructor
     *
     * Leaves the value of the enumerator indeterminate.
     */
    enum_base() = default;

    /** \brief Construct enhanced enum from a label enumerator
     *
     * Constructs an enumerator corresponding to \p label.
     *
     * \param label The label enumerator
     */
    constexpr enum_base(label_type label) noexcept : label {label} {}

    /** \brief Get the label enumerator
     *
     * \return The label enumerator corresponding to this enumerator
     */
    constexpr label_type get() const noexcept
    {
        return label;
    }

    /** \brief Convert to label enumerator
     *
     * \return \c this->get()
     */
    explicit constexpr operator label_type() const noexcept
    {
        return get();
    }

    /** \brief Get the value of the enumerator
     *
     * \return The value of the enumerator
     */
    constexpr const value_type& value() const noexcept
    {
        const auto n = static_cast<std::size_t>(label);
        return EnhancedEnum::values.at(n);
    }

private:
    LabelEnum label;
};

////////////////////////////////////////////////////////////////////////////////
// Template support
////////////////////////////////////////////////////////////////////////////////

/** \brief The enhanced enum type associated with \c LabelEnum
 *
 * \param LabelEnum A label enum type (<tt>enum class</tt>)
 */
template<typename LabelEnum>
using enhanced = decltype(enhance(std::declval<LabelEnum>()));

/** \brief Check if a type in an enhanced enum
 *
 * If \c T is a type that derives from \ref enum_base, derives from \c
 * std::true_type. Otherwise derives from \c std::false_type.
 *
 * \tparam T The type to check
 */
template<
    typename T
#ifndef IS_DOXYGEN
    , typename = void
#endif
>
struct is_enhanced_enum
#ifndef IS_DOXYGEN
    : std::false_type
#endif
{};

//! cond internal

template<typename T>
struct is_enhanced_enum<
    T,
    std::enable_if_t<
        std::is_base_of_v<
            enum_base<T, typename T::label_type, typename T::value_type>,
            T
        >
    >
> : std::true_type {};

//! \endcond

/** \brief Shorthand for \ref is_enhanced_enum
 */
template<typename T>
inline constexpr bool is_enhanced_enum_v = is_enhanced_enum<T>::value;

/** \brief Check if a type in a label enum
 *
 * If \c T is a type that has an associated enhanced enum type (see \ref
 * enhanced), derives from \c std::true_type. Otherwise derives from \c
 * std::false_type.
 *
 * \tparam T The type to check
 */
template<
    typename T
#ifndef IS_DOXYGEN
    , typename = void
#endif
>
struct is_label_enum
#ifndef IS_DOXYGEN
    : std::false_type
#endif
{};

//! \cond internal

template<typename T>
struct is_label_enum<T, std::void_t<enhanced<T>>> : std::true_type {};

//! \endcond

/** \brief Shorthand for \ref is_label_enum
 */
template<typename T>
inline constexpr bool is_label_enum_v = is_label_enum<T>::value;

/** \brief Makes an enhanced enum type
 *
 * If \c Enum is either an enhanced enum (see \ref is_enhanced_enum) or a label
 * enum (see \ref is_label_enum), has the associated enhanced enum as member
 * typedef \c type. Otherwise has no member typedefs.
 */
template<
    typename Enum
#ifndef IS_DOXYGEN
    , typename = void
#endif
>
struct make_enhanced;

//! \cond internal

template<typename Enum>
struct make_enhanced<Enum, std::enable_if_t<is_enhanced_enum_v<Enum>>>
{
    using type = Enum;
};

template<typename Enum>
struct make_enhanced<Enum, std::enable_if_t<is_label_enum_v<Enum>>>
{
    using type = enhanced<Enum>;
};

//! \endcond

/** \brief Shorthand for \ref make_enhanced
 */
template<typename Enum>
using make_enhanced_t = typename make_enhanced<Enum>::type;

/** \brief Check if two types are associated with the same enhanced enum type
 *
 * If \c T and \c U are either label enums or enhanced enums, and the enhanced
 * enum types are the same, derives from \c std::true_type. Otherwise derives
 * from \c std::false_type.
 *
 * This template is useful for writing generic comparison functions that accepts
 * both label and enhanced enums of the same kind.
 *
 * \code
 * template<
 *     typename Enum1, typename Enum2,
 *     typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
 * >
 * bool compare(Enum1 e1, Enum2 e2)
 * {
 *     // implementation can use ensure_enum(e1) to access the enhanced capabilities
 * }
 * \endcode
 */
template<
    typename T, typename U
#ifndef IS_DOXYGEN
    , typename = void
#endif
>
struct is_same_when_enhanced
#ifndef IS_DOXYGEN
    : std::false_type
#endif
{};

//! \cond internal

template<typename T, typename U>
struct is_same_when_enhanced<
    T, U,
    std::enable_if_t<
        std::is_same_v<make_enhanced_t<T>, make_enhanced_t<U>>
    >
> : std::true_type {};

//! \endcond

/** \brief Shorthand for \ref is_same_when_enhanced
 */
template<typename T, typename U>
inline constexpr bool is_same_when_enhanced_v = is_same_when_enhanced<T, U>::value;

/** \brief Ensure that the argument is an enhanced enumerator
 *
 * \param e The enumerator to promote
 *
 * \return If \p e is a label enum, the enhanced enumerator associated with
 * it. Otherwise \p e as is.
 *
 * \sa is_same_when_enhanced for an example how this might be used in generic
 * code
 */
template<typename Enum>
constexpr make_enhanced_t<Enum> ensure_enhanced(Enum e) noexcept
{
    return static_cast<make_enhanced_t<Enum>>(e);
}

////////////////////////////////////////////////////////////////////////////////
// Comparison functions
////////////////////////////////////////////////////////////////////////////////

//! \cond internal

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator==(Enum1 lhs, Enum2 rhs) noexcept
{
    return ensure_enhanced(lhs).get() == ensure_enhanced(rhs).get();
}

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator!=(Enum1 lhs, Enum2 rhs) noexcept
{
    return !(lhs == rhs);
}

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator<(Enum1 lhs, Enum2 rhs) noexcept
{
    return ensure_enhanced(lhs).get() < ensure_enhanced(rhs).get();
}

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator<=(Enum1 lhs, Enum2 rhs) noexcept
{
    return !(rhs < lhs);
}

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator>(Enum1 lhs, Enum2 rhs) noexcept
{
    return rhs < lhs;
}

template<
    typename Enum1, typename Enum2,
    typename = std::enable_if_t<is_same_when_enhanced_v<Enum1, Enum2>>
>
constexpr bool operator>=(Enum1 lhs, Enum2 rhs) noexcept
{
    return !(lhs < rhs);
}

// \endcond

}
